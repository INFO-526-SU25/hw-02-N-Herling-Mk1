---
title: "HW 02"
author: "Nathan Herling"
date: "2025-06-13"
_due: "Friday-June-13-2025"   
format:
  html:
    embed-resources: true
toc: true
#custom field '_due', 
#if you want to show in the document:**Due Date:** {{_due}}
---

## 0 - Setup

```{r setup, echo=FALSE}
#--------------------->
#################
# Package Setup #
#################
#Check if pacman [package manager] is installed, if not install it.
#throw [FYI] alert either way.
if (!requireNamespace("pacman", quietly = TRUE)) {
  message("Installing 'pacman' (not found locally)...")
  install.packages("pacman")
} else {
  message("[FYI]\n'pacman' already installed â€” skipping install.")
}
# use this line for installing/loading
# pacman::p_load()
# - packages to load stored in a variable (vector)
pkgs <- c(
  "tidyverse",
  "glue",
  "scales",
  "lubridate",
  "patchwork",
  "ggh4x",
  "ggrepel",
  "openintro",
  "ggridges",
  "dsbox",
  "janitor",
  "here",
  "knitr",
  "ggthemes",
  "ggplot2",
  "kableExtra",
  "palmerpenguins"
)

# - load from the character array/vector
pacman::p_load(char=pkgs)

# - install tidyverse/dsbox directly from Git Hub
# - this allows for the possible need to install on a repo. pull.
# - and, if it's already installed just thorw an alert.
if (!requireNamespace("dsbox", quietly = TRUE)) {
  message("Installing 'dsbox' from GitHub (not found locally)...")
  suppressMessages(devtools::install_github("tidyverse/dsbox"))
} else {
  message("[FYI]\n'dsbox' already installed â€” skipping GitHub install.")
}

# - alert to user packages loaded.
# Set number of columns (adjustable)
n_cols <- 4

# Add * to each package name
pkgs <- paste0("* ", pkgs)

# Calculate number of rows based on total packages
n_rows <- ceiling(length(pkgs) / n_cols)

# Pad with empty strings to complete grid
pkgs_padded <- c(pkgs, rep("", n_rows * n_cols - length(pkgs)))

# Create matrix (fill by row)
pkg_matrix <- matrix(pkgs_padded, nrow = n_rows, byrow = TRUE)

# Print header
cat("The packages loaded:")

# Loop and print each row (use invisible to suppress NULL)
invisible(apply(pkg_matrix, 1, function(row) {
  cat(paste(format(row, width = 22), collapse = ""), "\n")
}))
#-------------------------->
######################
# Basic set Theme up #
######################
# ---- set theme for ggplot2
ggplot2::theme_set(ggplot2::theme_minimal(base_size = 14))

# set width of code output
options(width = 65)

# set figure parameters for knitr
knitr::opts_chunk$set(
  fig.width = 7,        # 7" width
  fig.asp = 0.618,      # the golden ratio
  fig.retina = 3,       # dpi multiplier for displaying HTML output on retina
  fig.align = "center", # center align figures
  dpi = 300             # higher dpi, sharper image
)
## ---- end theme set up
```
## 1 - A new day, a new plot, a new geom

> **Question #1**
> <div style="background-color:#e0e0e0; margin:15px; padding:10px; border-radius:5px; border:1px solid #16DB65; overflow-wrap:anywhere; word-break:break-word; white-space:normal;">
> A new day, a new plot, a new geom. The goal of this exercise is to learn about a new type of plot (ridgeline plot) and to learn how to make it. Use the 
> ```geom_density_ridges()``` function from the ```ggridges``` package to make a ridge plot of Airbnb review scores of Edinburgh neighborhoods. The neighborhoods should be ordered by their median review scores. The data can be found in the ```dsbox``` package, and itâ€™s called ```edibnb```. Also include an interpretation for your visualization. You should review feedback from your Homework 1 to make sure you capture anything you may have missed previously.
> </div>


```{r}
#| label: label-me-1
#| echo: false
#| fig-asp: 0.63
#| fig-width: 7

# =======================================
# Diagnostics Summary Table Preparation
# =======================================

# Data Type
data_type <- class(edibnb$review_scores_rating)

# - info on the DSet
#print(help("edibnb"))

# - Summary Stats
summary_stats <- summary(edibnb$review_scores_rating)

# - Missing values
missing_count <- sum(is.na(edibnb$review_scores_rating))

# - IQR and Outlier Detection
q1 <- quantile(edibnb$review_scores_rating, 0.25, na.rm = TRUE)
q3 <- quantile(edibnb$review_scores_rating, 0.75, na.rm = TRUE)
iqr <- q3 - q1
lower_bound <- q1 - 1.5 * iqr
upper_bound <- q3 + 1.5 * iqr

outliers <- edibnb$review_scores_rating[!is.na(edibnb$review_scores_rating) &
                                          (edibnb$review_scores_rating < lower_bound |
                                           edibnb$review_scores_rating > upper_bound)]

# - Construct a table of key diagnostics
diagnostics_table <- tibble::tibble(
  Metric = c(
    "Data Type",
    "Min", "1st Quartile", "Median", "Mean", "3rd Quartile", "Max",
    "Missing Values",
    "IQR", "Lower Outlier Bound", "Upper Outlier Bound", "Outlier Count"
  ),
  Value = c(
    data_type,
    summary_stats[["Min."]],
    summary_stats[["1st Qu."]],
    summary_stats[["Median"]],
    summary_stats[["Mean"]],
    summary_stats[["3rd Qu."]],
    summary_stats[["Max."]],
    missing_count,
    iqr,
    lower_bound,
    upper_bound,
    length(outliers)
  )
)

# Print the diagnostics table with styled caption and highlighted row
diagnostics_table |>
  kable(
    caption = "<span style='font-weight:bold; font-size:1.2em;'>Table 1. Diagnostic Summary for <code>review_scores_rating</code> (edibnb data set)</span>",
    escape = FALSE
  ) |>
  kable_styling(full_width = FALSE, bootstrap_options = c("striped", "hover")) |>
  row_spec(
    which(diagnostics_table$Metric == "Missing Values"),   # ðŸ”§ Highlight "Missing Values" row
    background = "#fff9c4"  # ðŸ”§ Light yellow
  )

# =======================================
# Visualization: Ridge Plot by Neighborhood
# =======================================

# - Filter out rows with NA in neighbourhood or review_scores_rating
edibnb_clean <- edibnb |>
  filter(!is.na(neighbourhood), !is.na(review_scores_rating))

# - Calculate median review scores by neighborhood
median_scores <- edibnb_clean |>
  group_by(neighbourhood) |>
  summarize(median_score = median(review_scores_rating, na.rm = TRUE)) |>
  arrange(median_score)

# - Reorder neighborhoods by median score
edibnb_clean <- edibnb_clean |>
  mutate(neighbourhood = factor(neighbourhood, levels = median_scores$neighbourhood))

# ==== New: Calculate mean review scores for each neighborhood (for annotation) ====
mean_scores <- edibnb_clean |>
  group_by(neighbourhood) |>
  summarize(mean_score = mean(review_scores_rating, na.rm = TRUE))

# ==== Modified plot: add geom_text for mean scores offset to the right ====
# Create a named vector of colors for neighborhoods
neighborhood_colors <- setNames(viridis::viridis(length(levels(edibnb_clean$neighbourhood))), levels(edibnb_clean$neighbourhood))

# - Get the first and last neighborhood (lowest & highest median)
low_neigh <- levels(edibnb_clean$neighbourhood)[1]
high_neigh <- levels(edibnb_clean$neighbourhood)[length(levels(edibnb_clean$neighbourhood))]

# - Maximum x-position for annotation
max_annot_x <- max(mean_scores$mean_score, na.rm = TRUE) + 25

#===============
# Make the plot
#===============
g1 <- ggplot(edibnb_clean, aes(x = review_scores_rating, y = neighbourhood)) +
  geom_density_ridges(
    aes(color = neighbourhood),
    fill = "cornsilk4",
    alpha = 0.7,
    scale = 1.2,
    show.legend = FALSE
  ) +
  geom_point(
    data = mean_scores,
    aes(x = mean_score, y = neighbourhood, color = "Mean Score"),
    size = 3,
    shape = 18
  ) +
  geom_segment(
    data = mean_scores,
    aes(
      x = mean_score,
      xend = mean_score + 20,
      y = neighbourhood,
      yend = as.numeric(neighbourhood) + 0.5
    ),
    color = "black",
    linewidth = 0.3
  ) +
  ggrepel::geom_text_repel(
    data = mean_scores,
    aes(
      x = mean_score + 20,
      y = as.numeric(neighbourhood) + 0.5,
      label = round(mean_score, 1)
    ),
    hjust = 0,
    size = 3.2,
    color = "black",
    nudge_y = 0.15,
    segment.color = NA,
    direction = "y",
    box.padding = 0.3,
    point.padding = 0.5,
    show.legend = FALSE
  ) +
  annotate(             # - put an annotation next to the 'low' value
    "text",
    x = max_annot_x,
    y = 1.5,
    label = "Low",
    hjust = -1,
    size = 5,
    color = neighborhood_colors[[low_neigh]]
  ) +
  annotate(             # - put an annotation next to the 'high' value
    "text",
    x = max_annot_x,
    y = length(levels(edibnb_clean$neighbourhood)) + 0.5,
    label = "High",
    hjust = -1,
    size = 5,
    color = neighborhood_colors[[high_neigh]]
  ) +
  scale_x_continuous(name = "Review Scores Rating", limits = c(0, 150)) +
  scale_color_manual(
    name = "Legend",
    values = c(neighborhood_colors, "Mean Score" = "black"),
    breaks = "Mean Score",
    labels = "Mean Score"
  ) +
  labs(
    title = "Distribution of Airbnb Review Scores by Edinburgh Neighborhood\n", 
    y = "Neighborhood",
    caption = "Source: Inside Airbnb via Kaggle (data from June 2019)") +
  theme_ridges() +
  theme(
    legend.position = "right",
    legend.title = element_text(hjust = 0.6),
    axis.title.y = element_text(vjust = 1.5, hjust = 0.5),
    plot.title = element_text(hjust = 0.5),
    axis.title.x = element_text(hjust = 0.5),
    plot.caption = element_text(              # - stylizing the caption
      hjust = 0.5,    # right align
      color = "grey50",  # lighter grey
      size = 8
     )
  ) 

# - show the graph
g1

```
<div style="background-color:#e0e0e0; margin:15px; padding:10px; border-radius:5px; border:1px solid #16DB65; display:flex; align-items:center; justify-content:center; height:auto;">
  <strong><br>Interpretation</strong>
  The graph (`Distribution of Airbnb Review Scores by Edinburgh Neighborhood`) displays the distribution of Airbnb review scores across Edinburgh neighborhoods using ridgeline plots, with each neighborhoodâ€™s mean score marked by a diamond. The mean review scores are generally high, ranging from about 93.9 to 95.9. Some neighborhoods, like Morningside and Bruntsfield, show slightly higher average scores. The variation in score spread highlights differences in review consistency between neighborhoods, making it easier to compare where listings tend to receive better feedback.
</div>
## 2 - Foreign Connected PACs
<div style="background-color:#f0f0f0; margin:15px; padding:10px; border-radius:5px; border:1px solid #87CEEB;">
<b>Question #2a</b><br>
<div style="background-color:#e0e0e0; padding:2px; border-radius:5px; border:1px solid #16DB65; display:flex; align-items:center; justify-content:center; height:auto;">
  <strong><br>Contributions to US political parties from UK-connected PACs</strong>
</div>
</div>
```{r}
#| label: label-me-2a
#| echo: false
#| fig-width: 10


# Suppress readr column type messages
options(readr.show_col_types = FALSE) 
# ==================
# Load and combine data
# ==================

list_of_files <- fs::dir_ls(path = "data", regexp = "Foreign Connected PAC")

pac <- read_csv(list_of_files, id = "year") |> 
  clean_names() |>
  
  # Extract year from filename
  mutate(year = str_extract(year, "\\d{4}(?=\\.csv$)") |> as.integer()) |>
  
  # Split 'country_of_origin_parent_company' into 'country' and 'parent_company'
  separate(country_of_origin_parent_company,
           into = c("country", "parent_company"),
           sep = "/", 
           fill = "right", 
           extra = "merge") |>
  
  # Remove $ and , from numeric columns and convert to numeric
  mutate(across(c(dems, repubs), ~ as.numeric(str_replace_all(., "[\\$,]", "")))) |>
  
  # Keep only needed columns
  select(year, pac_name_affiliate, country, parent_company, dems, repubs)


# ==================
# Data Wrangle - Pivot and Summarize
# ==================

# Pivot data to longer format: create 'party' and 'amount' columns
pac_long <- pac |>
  pivot_longer(
    cols = c(dems, repubs),
    names_to = "party",
    values_to = "amount"
  ) |>
  
  # Replace party values with readable labels
  mutate(party = recode(party,
                        "dems" = "Democrat",
                        "repubs" = "Republican"))

# Filter for UK-origin PACs and remove NA values in amount
yearly_totals <- pac_long |>
  filter(country == "UK", !is.na(amount)) |>
  
  # Summarize total contributions by year and party
  group_by(year, party) |>
  summarise(amount = sum(amount), .groups = "drop")


# ==================
# Create the Plot
# ==================

g2a <- ggplot(yearly_totals, aes(x = year, y = amount, color = party)) +
  geom_line(linewidth = 1.2) +  # Keep line only

  scale_y_continuous(
    name = "Total amount",
    labels = label_dollar(scale = 1e-6, suffix = "M")
  ) +

  scale_x_continuous(
    name = "Year",
    breaks = scales::pretty_breaks()
  ) +

  scale_color_manual(
    values = c("Democrat" = "blue", "Republican" = "red"),
    labels = c("Democrat", "Republican"),
    name = "Party"
  ) +

  labs(title = "Contributions to US political parties from UK-connected PACs") +

  theme(
    legend.position.inside = c(0.9, 0.15),           # This may cause clipping warnings
    axis.title.x = element_text(hjust = 0),   # Align X-axis label left
    axis.title.y = element_text(hjust = 0)    # Align Y-axis label left
  )

# Show the plot
g2a

```
<div style="background-color:#f0f0f0; padding:10px; border-radius:5px; border:1px solid #87CEEB;">
<b>Question #2b</b><br>
<div style="background-color:#e0e0e0; padding:2px; border-radius:5px; border:1px solid #16DB65; display:flex; align-items:center; justify-content:center; height:auto;">
  <strong><br>Contributions to US political parties from Switzerland-connected PACs</strong>
</div>
</div>


```{r}
#| label: label-me-2b
#| echo: false
#| fig-width: 10

# - list_of_files already exists from above.
pac_2 <- read_csv(list_of_files, id = "year") |> 
  clean_names() |>
  
  # Extract year from filename
  mutate(year = str_extract(year, "\\d{4}(?=\\.csv$)") |> as.integer()) |>
  
  # Split 'country_of_origin_parent_company' into 'country' and 'parent_company'
  separate(country_of_origin_parent_company,
           into = c("country", "parent_company"),
           sep = "/", 
           fill = "right", 
           extra = "merge") |>
  
  # Remove $ and , from numeric columns and convert to numeric
  mutate(across(c(dems, repubs), ~ as.numeric(str_replace_all(., "[\\$,]", "")))) |>
  
  # Keep only needed columns
  select(year, pac_name_affiliate, country, parent_company, dems, repubs)

# ==================
# Export Unique Countries to CSV
# ==================
# Summarize contributions by country and party
# country_party_totals <- pac_2 |>
#   pivot_longer(cols = c(dems, repubs), names_to = "party", values_to = "amount") |>
#   filter(!is.na(country), !is.na(amount)) |>
#   group_by(country, party) |>
#   summarise(amount = sum(amount), .groups = "drop") |>
#   pivot_wider(names_from = party, values_from = amount, values_fill = 0) |>
#   mutate(total = dems + repubs) |>
#   arrange(desc(total))
# 
# # Write to CSV
# write_csv(country_party_totals, "country_contributions_summary.csv")

# ==================
# Data Wrangle - Pivot and Summarize
# ==================

pac_long <- pac_2 |>
  pivot_longer(
    cols = c(dems, repubs),
    names_to = "party",
    values_to = "amount"
  ) |>
  mutate(party = recode(party,
                        "dems" = "Democrat",
                        "repubs" = "Republican"))

yearly_totals <- pac_long |>
  filter(country == "Switzerland", !is.na(amount)) |>
  group_by(year, party) |>
  summarise(amount = sum(amount), .groups = "drop")

# ==================
# Create the Plot
# ==================

g2a <- ggplot(yearly_totals, aes(x = year, y = amount, color = party)) +
  geom_line(linewidth = 1.2) +
  scale_y_continuous(
    name = "Total amount",
    labels = label_dollar(scale = 1e-6, suffix = "M")
  ) +
  scale_x_continuous(
    name = "Year",
    breaks = scales::pretty_breaks()
  ) +
  scale_color_manual(
    values = c("Democrat" = "blue", "Republican" = "red"),
    labels = c("Democrat", "Republican"),
    name = "Party"
  ) +
  labs(title = "Contributions to US political parties from Switzerland-connected PACs") +
  theme(
    legend.position.inside = c(0.9, 0.15),
    axis.title.x = element_text(hjust = 0),
    axis.title.y = element_text(hjust = 0)
  )

# - Show the plot
# print(g2a)
g2a

```

## 3 - Median housing prices in the US
<div style="background-color:#f0f0f0; padding:10px; border-radius:5px; border:1px solid #87CEEB;">
<b>Question #3a</b><br>
<div style="background-color:#e0e0e0; padding:10px; border-radius:5px; border:1px solid #16DB65; display:flex; align-items:center; justify-content:center; height:auto;">
  <strong><br>Put the question here</strong>
</div>
</div>



```{r}
#| label: label-me-3a
#| echo: false

# Load the median housing data
median_housing <- read_csv("data/median-housing.csv") |>
  rename(date = DATE, price = MSPUS) |>
  mutate(date = ymd(date))  #

# Custom y-axis breaks (extend past 400,000 to ensure it shows)
y_breaks <- seq(40000, 440000, by = 40000)

# ADDED: Custom x-axis breaks (exclude endpoints)
x_breaks <- seq(1965, 2020, by = 5) |> paste0("-01-01") |> ymd()

# Create the visualization
g3a <- ggplot(median_housing, aes(x = date, y = price)) +
  geom_line(color = "#4d72e3") +
  
  # - REMOVED: Recession shading (geom_rect layer)
  
  # - REPLACED: Restrict x-axis and apply custom breaks
  scale_x_date(
    breaks = x_breaks,
    limits = c(ymd("1960-01-01"), ymd("2025-01-01")), # x-limits
    date_labels = "%Y"                                # format to '2000'
  ) +
  
  # Custom y-axis breaks and formatted labels
  scale_y_continuous(
    breaks = y_breaks, 
    labels = comma_format(),
    limits = c(0, 400000),     # y-limits
    expand = c(0, 0)
  ) +
  
  # Axis labels
  labs(
    title = "Median Housing Prices in the US\nNot seasonally adjusted",
    x = "Date", 
    y = "Dollars",
    
    # - Source annotation
    caption = "Sources: Census; HUD"
  ) +
  
  theme_minimal() +
  
  # - Right-align the caption
  theme(plot.caption = element_text(hjust = 1, size = 9, face = "italic"))

plot(g3a)

```

<div style="background-color:#f0f0f0; padding:10px; border-radius:5px; border:1px solid #87CEEB;">
<b>Question #3b</b><br>
<div style="background-color:#e0e0e0; padding:10px; border-radius:5px; border:1px solid #16DB65; display:flex; align-items:center; justify-content:center; height:auto;">
  <strong><br>Put the question here</strong>
</div>
</div>

```{r}
#| label: label-me-3b
#| echo: false

# - Load the median housing data - already loaded
# median_housing <- read_csv("data/median-housing.csv") |>
#   rename(date = DATE, price = MSPUS) |>
#   mutate(date = ymd(date))  # mutate to y-m-d format

# - Load the recession data
recessions <- read_csv("data/recessions.csv") |>
  rename(start = Peak, end = Trough) |>
  mutate(start = ymd(start), end = ymd(end))  # mutate to y-m-d format

# - Custom y-axis breaks (extend past 400,000 to ensure it shows)
y_breaks <- seq(40000, 440000, by = 40000)

# - Custom x-axis breaks (exclude endpoints)
x_breaks <- seq(1965, 2020, by = 5) |> paste0("-01-01") |> ymd()

# - Create the visualization
g3b <- ggplot(median_housing, aes(x = date, y = price)) +
  geom_line(color = "#4d72e3") +
  
  # - Recession shading
  geom_rect(data = recessions, aes(xmin = start, xmax = end, ymin = -Inf, ymax = Inf),
            inherit.aes = FALSE, fill = "gray", alpha = 0.3) +
  
   # - REPLACED: Restrict x-axis and apply custom breaks
  scale_x_date(
    breaks = x_breaks,
    limits = c(ymd("1960-01-01"), ymd("2025-01-01")),  # - set x-limits
    date_labels = "%Y"
  ) +
  
  #  - Custom y-axis breaks and formatted labels
  scale_y_continuous(
    breaks = y_breaks, 
    labels = comma_format(),
    limits = c(0, 400000),     # - set y-limits
    expand = c(0, 0)
  ) +
  
  # Axis labels
  labs(title = "Median Housing Prices in the US",
       x = "Date", y = "Dollars",
       # - Source annotation
       caption = "Sources: Census; HUD"
       ) +
  
  theme_minimal() +
  # - Right-align the caption
  theme(plot.caption = element_text(hjust = 1, size = 9, face = "italic"))

g3b

```

```{r}
#| label: label-me-3c
#| echo: false

```

## 4 - Expect More. Plot More.
<div style="background-color:#f0f0f0; padding:10px; border-radius:5px; border:1px solid #87CEEB; height:auto">
<b>Question #4</b><br>
<div style="background-color:#e0e0e0; padding:10px; border-radius:5px; border:1px solid #16DB65; display:flex; align-items:center; justify-content:center; height:auto;">
  <strong><br>Recreate the Target LOGO.<br>Describe steps..<br>(see code comments)</strong>
  
</div>
</div>

```{r}
#| label: label-me-4
#| echo: false

library(ggplot2)
library(ggforce)

# Define Target's signature red color
target_red <- "#e82118"

# Create a data frame for the concentric circles (outer red ring and inner white ring)
circles <- data.frame(
  x0 = 0, y0 = 0,                    # Center of both circles
  r = c(1, 0.7),                     # Radii for the outer red ring and inner white ring
  fill = c(target_red, "white")     # Fill colors for each ring
)

# Construct the plot
g1 <- ggplot() +
  # Draw the red and white rings (two concentric circles)
  geom_circle(data = circles, aes(x0 = x0, y0 = y0, r = r, fill = fill), color = NA) +
  
  # Draw the solid inner red circle (target bullseye center)
  geom_circle(aes(x0 = 0, y0 = 0, r = 0.3), fill = target_red, color = NA) +
  
  # Add the text "TARGET" beneath the bullseye
  annotate("text", x = 0, y = -1.4, label = "TARGET", color = target_red, size = 10, fontface = "bold") +
  
  # Add the registered trademark symbol next to "TARGET"
  annotate("text", x = 0.6, y = -1.52, label = "Â®", color = target_red, size = 8) +
  
  # Use fill colors as provided (don't map them to a color scale)
  scale_fill_identity() +
  
  # Ensure equal aspect ratio for x and y (perfect circles)
  coord_fixed() +
  
  # Remove all background, axes, and gridlines
  theme_void()

# Render the plot
plot(g1)




```
## 5 - Mirror, mirror on the wall, whoâ€™s the ugliest of them all?
<div style="background-color:#f0f0f0; padding:10px; border-radius:5px; border:1px solid #87CEEB;">
<b>Question #5</b><br>
<div style="background-color:#e0e0e0; padding:10px; border-radius:5px; border:1px solid #16DB65; display:flex; align-items:center; justify-content:center; height:auto;">
  <strong><br>Mirror, mirror on the wall, whoâ€™s the ugliest of them all? Make a plot of the variables in the penguins dataset from the palmerpenguins package. Your plot should use at least two variables, but more is fine too. First, make the plot using the default theme and color scales. Then, update the plot to be as ugly as possible. You will probably want to play around with theme options, colors, fonts, etc. The ultimate goal is the ugliest possible plot, and the sky is the limit!</strong>
</div>
</div>
```{r}
#| label: label-me-5a
#| echo: false

# Load necessary libraries

# Remove rows with missing values
penguins_clean <- na.omit(penguins)

# Create scatter plot: bill length vs flipper length, colored by species
g5a <- ggplot(data = penguins_clean, aes(x = bill_length_mm, y = flipper_length_mm, color = species)) +
  geom_point() +
  labs(
    title = "Bill Length vs Flipper Length by Species",
    x = "Bill Length (mm)",
    y = "Flipper Length (mm)"
  )

# - show it
g5a

```

```{r}
#| label: label-me-5b
#| echo: false

# - penguins already loaded..
# penguins_clean <- na.omit(penguins)

# library(plotly)
# # Create scatter plot: bill length vs flipper length, colored by species
# p <- plot_ly(
#   data = penguins_clean,
#   x = ~bill_length_mm,
#   y = ~flipper_length_mm,
#   z = ~body_mass_g,
#   color = ~species,
#   colors = c("darkorange", "dodgerblue", "forestgreen"),
#   type = "scatter3d",
#   mode = "markers",
#   marker = list(size = 5)
# )
# 
# p <- layout(
#   p,
#   scene = list(
#     xaxis = list(title = "Bill Length (mm)"),
#     yaxis = list(title = "Flipper Length (mm)"),
#     zaxis = list(title = "Body Mass (g)")
#   ),
#   title = "3D Scatter Plot: Bill Length vs Flipper Length vs Body Mass"
# )
# 
# p

library(plotly)
library(palmerpenguins)
library(plotly)
library(palmerpenguins)

penguins_clean <- na.omit(penguins)

normalize <- function(x) (x - min(x)) / (max(x) - min(x))

x_norm <- normalize(penguins_clean$bill_length_mm)
y_norm <- normalize(penguins_clean$flipper_length_mm)
z_norm <- normalize(penguins_clean$body_mass_g)

theta <- 2 * pi * x_norm
phi <- pi * y_norm
r <- 1 + 0.3 * (z_norm - 0.5)

x_sphere <- r * sin(phi) * cos(theta)
y_sphere <- r * sin(phi) * sin(theta)
z_sphere <- r * cos(phi)

sphere_res <- 30
sphere_theta <- seq(0, 2*pi, length.out = sphere_res)
sphere_phi <- seq(0, pi, length.out = sphere_res)

mesh_coords <- expand.grid(theta = sphere_theta, phi = sphere_phi)
mesh_x <- sin(mesh_coords$phi) * cos(mesh_coords$theta)
mesh_y <- sin(mesh_coords$phi) * sin(mesh_coords$theta)
mesh_z <- cos(mesh_coords$phi)

mesh <- list(
  type = 'mesh3d',
  x = mesh_x,
  y = mesh_y,
  z = mesh_z,
  alphahull = 20,
  opacity = 0.2,
  color = 'lightgrey',
  name = 'sphere'
)

angles <- seq(0, 2 * pi, length.out = 100)

frames <- lapply(seq_along(angles), function(i) {
  angle <- angles[i]
  list(
    name = as.character(i),
    layout = list(
      scene = list(
        camera = list(
          eye = list(
            x = 2 * cos(angle),
            y = 2 * sin(angle),
            z = 0.7
          )
        )
      )
    )
  )
})

p <- plot_ly() %>%
  add_trace(
    type = "scatter3d",
    mode = "markers",
    x = x_sphere,
    y = y_sphere,
    z = z_sphere,
    color = penguins_clean$species,
    colors = c("darkorange", "dodgerblue", "forestgreen"),
    marker = list(size = 4)
  ) %>%
  add_trace(mesh) %>%
  layout(
    scene = list(
      xaxis = list(title = "X", range = c(-1.5, 1.5)),
      yaxis = list(title = "Y", range = c(-1.5, 1.5)),
      zaxis = list(title = "Z", range = c(-1.5, 1.5)),
      aspectmode = "cube",
      camera = list(
        eye = list(x = 2, y = 0, z = 0.7)  # initial camera position
      )
    ),
    title = "Penguin Data on Continuously Rotating Sphere",
    updatemenus = list(
      list(
        type = "buttons",
        buttons = list(
          list(
            label = "Play",
            method = "animate",
            args = list(NULL, list(frame = list(duration = 50, redraw = TRUE),
                                   transition = 0,
                                   fromcurrent = TRUE,
                                   mode = "immediate"))
          ),
          list(
            label = "Pause",
            method = "animate",
            args = list(NULL, list(frame = list(duration = 0, redraw = FALSE),
                                   mode = "immediate"))
          )
        )
      )
    )
  )

# Assign frames explicitly to the plotly object
p$x$frames <- frames

# Animation options to smooth it out
p <- p %>%
  animation_opts(
    frame = 50,
    transition = 0,
    redraw = TRUE,
    easing = "linear",
    mode = "immediate"
  )

p



```
